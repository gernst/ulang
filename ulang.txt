import prelude

type Name

data Type
  = param: Name
  | app: Name (List Type)

data Expr
  = bound: Nat
  | free: Name Type
  | op    (name: Name)  (type: Type)
  | app   (fun:  Expr)  (arg:  Expr)
  | lam   (bound: Name) (body: Expr)

data Pattern
  = free:  Name → Type → Pattern
  | op:    Name → Type → Pattern
  | app:   Pattern → Pattern → Pattern

free: Type → List Name
free (param name) = name :: []
   | (app name args) = flatmap free args

function free: Expr → List Name
free (bound n) = []
   | (free name type) = name :: []
   | (op name type) = []
   | (app fun arg) = (free fun) ++ (free arg)
   | (lam bound body) = (free body) -- bound

// lots of clashes -> def
free: Pattern → List Name
  | (free name type) = name :: []
  | (op name typ) = []
  | (app fun arg) = (free fun) ++ (free arg)

/*
// app with n args from Expr has a clash with app from Type 
app: Expr → List Expr → Expr
app fun args
  = foldl fun app args

lam: List Name → Expr → Expr
lam bounds body
  = foldr body lam bounds
*/

type Stack a = List (Val a);
type Model a = Map Name (Val a);
type Closure a = Val a → Model a → Val a;

data Val a
  = const: a → Val a
  | clos: Closure a → Val a

eval: Expr (Stack a) (Model a) → Val a
apply: Val a → Closure a

apply (clos f) = f

eval (bound n) stack model
  = nth n stack

eval (op name typ) stack model
  = get name model

eval (app fun arg) stack model
  = apply (eval fun stack model)
          (eval arg stack model)
          model

eval (lam x body) stack model
  = fun (λ a model. eval body (a :: stack) model)
